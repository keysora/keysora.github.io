<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FoX GeM</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background-color: #000;
      color: white;
      overflow: hidden;
      touch-action: manipulation;
    }

    canvas#game {
      display: block;
      margin: 20px auto;
      background: #000;
      z-index: 2;
      position: relative;
    }

    #game-over-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: crimson;
      font-size: 3em;
      font-weight: bold;
      z-index: 5;
      display: none;
      text-align: center;
    }

    .menu {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      justify-content: center;
      position: relative;
      z-index: 3;
    }

    .button {
      padding: 10px 20px;
      background-color: crimson;
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1em;
      z-index: 10;
    }

    .sound-control {
      position: fixed;
      top: 15px;
      right: 15px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid crimson;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 20px;
      cursor: pointer;
    }

    .popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border: 2px solid crimson;
      border-radius: 15px;
      display: none;
      flex-direction: column;
      gap: 10px;
      z-index: 100;
      width: 80%;
      max-width: 400px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .close-btn {
      align-self: flex-end;
      cursor: pointer;
      color: crimson;
      font-size: 1.5em;
      margin-bottom: 10px;
    }

    .leaderboard-entry {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #333;
    }

    .leaderboard-entry:nth-child(1) { color: gold; font-weight: bold; }
    .leaderboard-entry:nth-child(2) { color: silver; font-weight: bold; }
    .leaderboard-entry:nth-child(3) { color: #cd7f32; font-weight: bold; }
    .current-user { color: crimson !important; }

    .control-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 4;
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr 1fr;
      pointer-events: none;
    }

    .control-zone {
      pointer-events: auto;
      opacity: 0;
    }

    @media (max-width: 768px) {
      canvas#game {
        width: 100%;
        height: auto;
        max-width: 100vw;
        max-height: 70vh;
      }
    }
  </style>
</head>
<body>
  <div class="sound-control" id="soundControl">ðŸ”Š</div>
  <h1 style="text-align: center; z-index:3; position:relative; color: crimson;">FoX GeM</h1>
  <div id="game-over-text">GAME OVER<br><span style="font-size: 0.6em;">Score: <span id="final-score">0</span></span></div>
  <canvas id="game" width="400" height="400"></canvas>

  <div class="control-overlay">
    <div class="control-zone" data-direction="up"></div>
    <div class="control-zone" data-direction="up"></div>
    <div class="control-zone" data-direction="up"></div>
    <div class="control-zone" data-direction="left"></div>
    <div class="control-zone"></div>
    <div class="control-zone" data-direction="right"></div>
    <div class="control-zone" data-direction="down"></div>
    <div class="control-zone" data-direction="down"></div>
    <div class="control-zone" data-direction="down"></div>
  </div>

  <div class="menu">
    <button class="button" onclick="startGame()">Play</button>
    <button class="button" onclick="showAccountPopup()">Account</button>
    <button class="button" onclick="showLeaderboardPopup()">Leaderboard</button>
  </div>

  <!-- Account Popup -->
  <div class="popup" id="accountPopup">
    <span class="close-btn" onclick="hideAccountPopup()">Ã—</span>
    <h2 style="color: crimson; text-align: center;">Account</h2>
    <div id="accountInfo">
      <p>Loading user data...</p>
    </div>
  </div>

  <!-- Leaderboard Popup -->
  <div class="popup" id="leaderboardPopup">
    <span class="close-btn" onclick="hideLeaderboardPopup()">Ã—</span>
    <h2 style="color: crimson; text-align: center;">Leaderboard</h2>
    <div id="leaderboardContent">
      <p>Loading leaderboard...</p>
    </div>
  </div>

  <script>
    // Game variables
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const box = 20;
    let snake = [];
    let direction = 'right';
    let food;
    let gameLoop;
    let score = 0;
    const gameOverText = document.getElementById('game-over-text');
    const finalScoreElement = document.getElementById('final-score');

    // Sound effects
    const soundEffects = {
      eat: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3'),
      gameOver: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-retro-arcade-lose-2027.mp3'),
      move: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-quick-jump-arcade-game-239.mp3')
    };

    let soundEnabled = true;
    document.getElementById('soundControl').addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      document.getElementById('soundControl').textContent = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
    });

    function playSound(sound) {
      if (soundEnabled && soundEffects[sound]) {
        soundEffects[sound].currentTime = 0;
        soundEffects[sound].play().catch(e => console.log('Sound error:', e));
      }
    }

    // Game initialization
    function initGame() {
      snake = [{x: 9 * box, y: 10 * box}];
      direction = 'right';
      generateFood();
      score = 0;
      
      if (gameLoop) clearInterval(gameLoop);
      gameLoop = setInterval(draw, 150);
    }

    function generateFood() {
      food = {
        x: Math.floor(Math.random() * 20) * box,
        y: Math.floor(Math.random() * 20) * box,
      };
      
      // Check if food appears on snake
      for (let i = 0; i < snake.length; i++) {
        if (food.x === snake[i].x && food.y === snake[i].y) {
          generateFood();
          break;
        }
      }
    }

    function draw() {
      // Background with grid
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw grid
      ctx.strokeStyle = 'rgba(50, 200, 50, 0.3)';
      ctx.lineWidth = 0.5;
      for (let i = 0; i < canvas.width; i += box) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, canvas.height);
        ctx.stroke();
      }
      for (let j = 0; j < canvas.height; j += box) {
        ctx.beginPath();
        ctx.moveTo(0, j);
        ctx.lineTo(canvas.width, j);
        ctx.stroke();
      }

      // Draw snake
      for (let i = 0; i < snake.length; i++) {
        ctx.fillStyle = i === 0 ? 'crimson' : 'darkred';
        ctx.fillRect(snake[i].x, snake[i].y, box, box);
        
        // Draw eyes
        if (i === 0) {
          ctx.fillStyle = 'white';
          const eyeSize = box / 5;
          const eyeOffset = box / 4;
          
          if (direction === 'right') {
            ctx.fillRect(snake[i].x + box - eyeOffset, snake[i].y + eyeOffset, eyeSize, eyeSize);
            ctx.fillRect(snake[i].x + box - eyeOffset, snake[i].y + box - eyeOffset * 2, eyeSize, eyeSize);
          } else if (direction === 'left') {
            ctx.fillRect(snake[i].x + eyeOffset - eyeSize, snake[i].y + eyeOffset, eyeSize, eyeSize);
            ctx.fillRect(snake[i].x + eyeOffset - eyeSize, snake[i].y + box - eyeOffset * 2, eyeSize, eyeSize);
          } else if (direction === 'up') {
            ctx.fillRect(snake[i].x + eyeOffset, snake[i].y + eyeOffset - eyeSize, eyeSize, eyeSize);
            ctx.fillRect(snake[i].x + box - eyeOffset * 2, snake[i].y + eyeOffset - eyeSize, eyeSize, eyeSize);
          } else if (direction === 'down') {
            ctx.fillRect(snake[i].x + eyeOffset, snake[i].y + box - eyeOffset, eyeSize, eyeSize);
            ctx.fillRect(snake[i].x + box - eyeOffset * 2, snake[i].y + box - eyeOffset, eyeSize, eyeSize);
          }
        }
      }

      // Draw food
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(food.x + box/2, food.y + box/2, box/2 - 2, 0, Math.PI * 2);
      ctx.fill();

      // Movement
      let headX = snake[0].x;
      let headY = snake[0].y;

      if (direction === 'left') headX -= box;
      if (direction === 'right') headX += box;
      if (direction === 'up') headY -= box;
      if (direction === 'down') headY += box;

      // Collision detection
      if (
        headX < 0 || headX >= canvas.width ||
        headY < 0 || headY >= canvas.height ||
        collision({x: headX, y: headY}, snake)
      ) {
        gameOver();
        return;
      }

      // Eat food
      if (headX === food.x && headY === food.y) {
        playSound('eat');
        score += 3;
        generateFood();
      } else {
        snake.pop();
      }

      snake.unshift({x: headX, y: headY});
    }

    function collision(head, array) {
      for (let i = 0; i < array.length; i++) {
        if (head.x === array[i].x && head.y === array[i].y) {
          return true;
        }
      }
      return false;
    }

    async function gameOver() {
      clearInterval(gameLoop);
      playSound('gameOver');
      finalScoreElement.textContent = score;
      gameOverText.style.display = 'block';
      await saveScore();
    }

    function startGame() {
      gameOverText.style.display = 'none';
      initGame();
    }

    // API Integration
    async function saveScore() {
      if (!window.Telegram?.WebApp?.initDataUnsafe?.user) {
        console.log("Not in Telegram WebApp, score not saved");
        return;
      }

      const user = window.Telegram.WebApp.initDataUnsafe.user;
      try {
        const response = await fetch('/api/save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            telegramId: user.id,
            username: user.username,
            firstName: user.first_name,
            lastName: user.last_name,
            score: score
          })
        });
        const data = await response.json();
        console.log("Score saved:", data);
      } catch (error) {
        console.error("Save error:", error);
      }
    }

    async function updateUserInfo() {
      if (!window.Telegram?.WebApp?.initDataUnsafe?.user) {
        document.getElementById('accountInfo').innerHTML = `
          <p>Not logged in via Telegram</p>
          <p>Play as guest</p>
        `;
        return;
      }
      
      const userId = window.Telegram.WebApp.initDataUnsafe.user.id;
      try {
        const response = await fetch(`/api/user/${userId}`);
        const data = await response.json();
        
        if (data.success) {
          document.getElementById('accountInfo').innerHTML = `
            <p><strong>Username:</strong> ${data.user.username}</p>
            <p><strong>Name:</strong> ${data.user.firstName} ${data.user.lastName}</p>
            <p><strong>Member since:</strong> ${new Date(data.user.joinDate).toLocaleDateString()}</p>
            <hr>
            <p><strong>Best Score:</strong> ${data.stats.bestScore}</p>
            <p><strong>Games Played:</strong> ${data.stats.gamesPlayed}</p>
          `;
        } else {
          document.getElementById('accountInfo').innerHTML = `<p>Error loading user data</p>`;
        }
      } catch (error) {
        console.error("User info error:", error);
        document.getElementById('accountInfo').innerHTML = `<p>Error loading user data</p>`;
      }
    }

    async function loadLeaderboard() {
      try {
        const response = await fetch('/api/leaderboard');
        const data = await response.json();
        
        if (data.success) {
          let html = '<div class="leaderboard-list">';
          data.leaders.forEach((leader, index) => {
            const isCurrent = window.Telegram?.WebApp?.initDataUnsafe?.user?.id === leader.user.telegramId;
            html += `
              <div class="leaderboard-entry ${isCurrent ? 'current-user' : ''}">
                <span>${index + 1}. ${leader.user.firstName || leader.user.username || 'Anonymous'}</span>
                <span>${leader.score}</span>
              </div>
            `;
          });
          html += '</div>';
          document.getElementById('leaderboardContent').innerHTML = html;
        } else {
          document.getElementById('leaderboardContent').innerHTML = '<p>Error loading leaderboard</p>';
        }
      } catch (error) {
        console.error("Leaderboard error:", error);
        document.getElementById('leaderboardContent').innerHTML = '<p>Error loading leaderboard</p>';
      }
    }

    // Popup controls
    function showAccountPopup() {
      updateUserInfo();
      document.getElementById('accountPopup').style.display = 'flex';
    }

    function hideAccountPopup() {
      document.getElementById('accountPopup').style.display = 'none';
    }

    function showLeaderboardPopup() {
      loadLeaderboard();
      document.getElementById('leaderboardPopup').style.display = 'flex';
    }

    function hideLeaderboardPopup() {
      document.getElementById('leaderboardPopup').style.display = 'none';
    }

    // Touch controls
    document.querySelectorAll('.control-zone').forEach(zone => {
      zone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const newDirection = zone.getAttribute('data-direction');
        if (newDirection && direction !== oppositeDirection(newDirection)) {
          playSound('move');
          direction = newDirection;
        }
      });
    });

    function oppositeDirection(dir) {
      switch (dir) {
        case 'left': return 'right';
        case 'right': return 'left';
        case 'up': return 'down';
        case 'down': return 'up';
        default: return '';
      }
    }

    // Keyboard controls
    document.addEventListener('keydown', e => {
      if (['ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown', 'a', 'w', 'd', 's'].includes(e.key)) {
        e.preventDefault();
      }

      if ((e.key === 'ArrowLeft' || e.key === 'a') && direction !== 'right') {
        playSound('move');
        direction = 'left';
      } else if ((e.key === 'ArrowUp' || e.key === 'w') && direction !== 'down') {
        playSound('move');
        direction = 'up';
      } else if ((e.key === 'ArrowRight' || e.key === 'd') && direction !== 'left') {
        playSound('move');
        direction = 'right';
      } else if ((e.key === 'ArrowDown' || e.key === 's') && direction !== 'up') {
        playSound('move');
        direction = 'down';
      }
    });

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      if (!canvas.getContext) {
        alert("Your browser doesn't support Canvas. Please update your browser.");
        return;
      }

      if (window.Telegram?.WebApp) {
        window.Telegram.WebApp.expand();
        window.Telegram.WebApp.enableClosingConfirmation();
        window.Telegram.WebApp.BackButton.show();
        
        window.Telegram.WebApp.BackButton.onClick(() => {
          window.Telegram.WebApp.close();
        });
      }

      // Start game automatically or wait for button click
      // startGame(); // Uncomment for auto-start
    });
  </script>
</body>
</html>
